# 선형시간 정렬 알고리즘-counting sort

### Counting Sort

- n개의 정수를 정렬하라. 단 모든 정수는 0에서 k 사이의 정수이다.

  ex. n명의 학생들의 시험 점수를 정렬하라. 단 모든 점수는 100 이하의 양의 정수이다.

- **수의 크기 제한이 있는 경우 사용하기 좋은 알고리즘**

- k=5인 경우의 예

  A :8개의 숫자 배열

  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
  | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  |  2   |  5   |  3   |  0   |  2   |  3   |  0   |  3   |

  (a)

  C : k+1 크기의 counting 배열

  |  0   |  1   |  2   |  3   |  4   |  5   |
  | :--: | :--: | :--: | :--: | :--: | :--: |
  |  2   |  0   |  2   |  3   |  0   |  1   |

   0~k까지의 정수의 개수를 카운트 한다.

  (b)

  누적합을 계산한다.

  각 i번째 항의 의미 : i보다 작거나 같은 것의 개수 

  C

  |  0   |  1   |  2   |  3   |  4   |  5   |
  | :--: | :--: | :--: | :--: | :--: | :--: |
  |  2   |  2   |  4   |  7   |  7   |  8   |

  (c)

  B : 정렬 후

  A의 뒤부터 앞으로 A[i]의 값을 탐색

  A[8]=3

  3보다 작거나 같은 것이 7개이므로 3이 들어갈 수 있는 가장 마지막 인덱스인 b[7]에 3을 넣어주고 C[3]--를 해줌. 

  | 1    | 2    | 3    | 4    | 5    | 6    | 7     | 8    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- |
  |      |      |      |      |      |      | **3** |      |

  C

  |  0   |  1   |  2   |    3     |  4   |  5   |
  | :--: | :--: | :--: | :------: | :--: | :--: |
  |  2   |  2   |  4   | **7->6** |  7   |  8   |

  (d)

  A[7]=0

  B

  | 1    | 2     | 3    | 4    | 5    | 6    | 7    | 8    |
  | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
  |      | **0** |      |      |      |      | 3    |      |

  C

  |    0     |  1   |  2   |  3   |  4   |  5   |
  | :------: | :--: | :--: | :--: | :--: | :--: |
  | **2->1** |  2   |  4   |  6   |  7   |  8   |

  (f)

  A[6]=3

  B

  | 1    | 2    | 3    | 4    | 5    | 6     | 7    | 8    |
  | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- |
  |      | 0    |      |      |      | **3** | 3    |      |

  C

  |  0   |  1   |  2   |    3     |  4   |  5   |
  | :--: | :--: | :--: | :------: | :--: | :--: |
  |  1   |  2   |  4   | **6->5** |  7   |  8   |

  .........

  (g) 최종

  A[1]=2

  B

  |      |      |       |      |      |      |      |      |
  | :--: | :--: | :---: | :--: | :--: | :--: | :--: | :--: |
  |  0   |  0   | **2** |  2   |  3   |  3   |  3   |  5   |

  C

  |  0   |    1     |  2   |  3   |  4   |  5   |
  | :--: | :------: | :--: | :--: | :--: | :--: |
  |  0   | **1->0** |  0   |  0   |  0   |  0   |

- **pseudocode**

  ```pseudocode
  COUNTING-SORT(A,B,K)
  1    for i<- 0 to k
  2        do C[i] <- 0
  3    for j <- 1 to length[A]
  4        do C[A[j]] <- C[A[j]]+1
  5    ▷ C[i] now contains the number of elements equals to i. = 개수 세기
  6    for i <- 1 to k
  7        do C[i] <- C[i]+C[i-1]
  8    ▷ C[i] now contains the number of elements less than or equal to i. = 누적합
  9    for j <- length[A] downto 1
  10        do B[C[A[j]]]<-A[j]
  11            C[A[j]]<-C[A[j]]-1
  ```

- **시간복잡도**

  - O(n+k), 또는 O(n) if k=O(n).

  - k가 클 경우 비실용적

  - stable 정렬 알고리즘 

    "입력에 동일한 값이 있을 대 입력에 먼저 나오는 값이 출력에도 먼저 나온다."

    **Counting 정렬은 stable하다.**

